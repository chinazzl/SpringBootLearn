server:
  port: 8011
spring:
  sharding-sphere:
    datasource:
      names: ds0
      ds0:
        type: com.zaxxer.hikari.HikariDataSource
        driverClassName: com.mysql.jdbc.Driver
        jdbcUrl: jdbc:mysql://127.0.0.1/test?userUnicode=true&characterEncoding=utf-8&serverTimezone=UTC&useSSL=true
        username: root
        password: password
      ds1:
        type: com.zaxxer.hikari.HikariDataSource
        driverClassName: com.mysql.jdbc.Driver
        jdbcUrl: jdbc:mysql://127.0.0.1/shirovue?userUnicode=true&characterEncoding=utf-8&serverTimezone=UTC&useSSL=true
        username: root
        password: password
        # Oracle
#        type: com.zaxxer.hikari.HikariDataSource
#        driverClassName: oracle.jdbc.OracleDriver
#        jdbcUrl: jdbc:oracle:thin:@localhost:1521:xe
#        username: root
#        password: password

    sharding:
      tables:
        t_order:
        # 逻辑表名
#        t_file:
          #指定orders表的分布情况，配置表在哪个数据库中，表名称是什么（groovy语法）
          actual-data-nodes: ds0.t_order_$->{0..1}
          #指定orders表里主键id生成策略
          key-generator:
            column: order_id
            type: SNOWFLAKE
            #指定分片策略。根据id的奇偶性来判断插入到哪个表
          table-strategy:
            # 行表达式分片策略（InlineShardingStrategy）
            # 对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持，只支持单分片键。
            # 对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发
            # InlineShardingStrategy策略不支持对分片字段采用>=、<=、>、<、BETWEEN查询
            inline:
              sharding-column: order_id
              algorithm-expression: t_order_$->{(order_id+1)%2}
            # 标准分片策略（StandardShardingStrategy）
            # 对应StandardShardingStrategy。提供对SQL语句中的=, >, <, >=, <=, IN和BETWEEN AND的分片操作支持。
            # StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。
            # PreciseShardingAlgorithm是必选的，用于处理=和IN的分片。RangeShardingAlgorithm是可选的，
            # 用于处理BETWEEN AND, >, <, >=, <=分片，如果不配置RangeShardingAlgorithm，SQL中的BETWEEN AND将按照全库路由处理。
#            standard:
#              sharding-column: id
#              precise-algorithm-class-name: org.basic.config.shardingjdbc.PreciseAlgorithmConfig
#              range-algorithm-class-name: org.basic.config.shardingjdbc.RangeAlgorithmConfig
            # 复合分片策略（ComplexShardingStrategy）
            # 对应ComplexShardingStrategy。复合分片策略。
            # 提供对SQL语句中的=, >, <, >=, <=, IN和BETWEEN AND的分片操作支持。
            # ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，
            # 而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度。
#            complex:
#              sharding-columns: id,storage_type
#              algorithm-class-name: org.basic.config.shardingjdbc.ComplexAlgorithmConfig

            # Hint分片策略（HintShardingStrategy） ShardingSphere 使用 ThreadLocal 管理分片键值进行 Hint 强制路由。
            # 可以通过编程的方式向 HintManager 中添加分片值，该分片值仅在当前线程内生效。
            # 对应HintShardingStrategy。通过Hint指定分片值而非从SQL中提取分片值的方式进行分片的策略。
#            hint:
#              algorithm-class-name: org.basic.config.shardingjdbc.HintManagerConfig
            # 不分片策略
            #对应NoneShardingStrategy。不分片的策略。
            #            none:
        t_order_item:
          actual-data-nodes: ds0.t_order_item_$->{0..1}
          key-generator:
            column: id
            type: SNOWFLAKE
          table-strategy:
            inline:
              sharding-column: order_id
              algorithm-expression: t_order_item_$->{(order_id +1)%2}
      # 广播表，像标准代码表、字典表
      # 要求向 t_dict 写入数据的时候，将数据同时写 2 个库中的 t_dict 表，查询的时候随便选择一个即可
      broadcast-tables:
        - t_dic
      # 当 2 个表的路由字段相同的时候，可以设置表关联，可以避免笛卡尔积查询，下面设置 t_order 和 t_order_item 关联
      binding-tables:
        - t_order
        - t_order_item
    props:
      sql:
        show: true
mybatis:
  type-aliases-package: org.basic.mapper

